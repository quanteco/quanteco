% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/moranstest.R
\name{morans.test}
\alias{morans.test}
\title{Monte Carlo Test for Moran's I}
\usage{
morans.test(X, W, N = 999, test = c("positive", "negative", "two-sided"),
  graph = F, print.results = T)
}
\arguments{
\item{X}{a vector of values}

\item{W}{a neighborhood matrix}

\item{N}{the number of permutations or randomizations; default is 999}

\item{test}{a character sting specifying the alternative hypothesis, must be one of "positve" (default), "negative", or "two-sided".}

\item{graph}{a logical statement specifying if a graph of the test should be returned.}

\item{print.results}{a logical statement specifying if results should be printed (\code{TRUE}; default) or not (\code{FALSE})}
}
\description{
Performs a Monte Carlo test for Moran's I, given a vector (\strong{X}) and a neighborhood matrix (\strong{W})
}
\details{
While calculating Moran's I is helpful, we need some way to determine if the value is higher (or lower) than expected by chance. There are a variety of ways to perform such a test. A fairly robust approach that doesn't require the assumption of normality is to perform a randomization or permutation test. Basically, we can rearrange the elements of x and calculate Moran's I for each rearrangement. Depending on the number of elements in x, we can either perform all possible rearrangements (i.e., a permutation test) or a large number of combinations (i.e., a randomization test).
}
\examples{
library(matrix)
set.seed(200)
n<-100
y<-rnorm(n)
D<-array(dim=rep(length(y),2))
diag(D)<-0
D[lower.tri(D,diag=F)]<-runif(length(D[lower.tri(D,diag=F)]),0,500)
library(Matrix)
D<-forceSymmetric(D,uplo="L")
W<-weighmatrix(D)
y<-sim.autocorrelated(y,0.1,W)
morans.test(y,W,graph=T)
}
\seealso{
\code{\link{weightmatrix}}, \code{\link{morans.i}}
}

